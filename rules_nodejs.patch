diff --git a/internal/common/module_mappings.bzl b/internal/common/module_mappings.bzl
index c523b50a..0ca35995 100644
--- a/internal/common/module_mappings.bzl
+++ b/internal/common/module_mappings.bzl
@@ -80,7 +80,7 @@ def get_module_mappings(label, attrs, srcs = [], workspace_name = None, mappings
             mr = "%s/%s" % (workspace_name, mr)
         elif label.workspace_root:
             mr = "%s/%s" % (label.workspace_root, mr)
-        if attrs.module_root and attrs.module_root != ".":
+        if hasattr(attrs, "module_root") and attrs.module_root and attrs.module_root != ".":
             if attrs.module_root.endswith(".ts"):
                 if workspace_name:
                     # workspace_name is set only when doing module mapping for runtime.
diff --git a/internal/node/bazel_require_script.js b/internal/node/bazel_require_script.js
index 3d062b29..1dca5412 100644
--- a/internal/node/bazel_require_script.js
+++ b/internal/node/bazel_require_script.js
@@ -501,7 +501,15 @@ exports.escapeFunction = (root) => {
         return false;
     }
     function isOutPath(str) {
-        return !root || (!str.startsWith(root + path.sep) && str !== root);
+        return !root || (!str.startsWith(root + path.sep) && str !== root) ||
+            // don't allow symlink to escape to duplicate node_modules tree
+            (process.env.NODE_MODULES_ROOT &&
+                str.startsWith(root + path.sep + process.env.NODE_MODULES_ROOT + path.sep)) ||
+            // also cover the external legacy runfiles case for the above (incase
+            // --noexternal_legacy_runfiles not set)
+            (process.env.NODE_MODULES_ROOT && process.env.TEST_WORKSPACE &&
+                str.startsWith(root + process.env.TEST_WORKSPACE + path.sep + 'external' + path.sep +
+                    process.env.NODE_MODULES_ROOT + path.sep));
     }
     return { isEscape, isOutPath };
 };
diff --git a/internal/node/node.bzl b/internal/node/node.bzl
index 2c0bfefd..4ccb6885 100644
--- a/internal/node/node.bzl
+++ b/internal/node/node.bzl
@@ -25,7 +25,7 @@ load("//internal/common:expand_into_runfiles.bzl", "expand_location_into_runfile
 load("//internal/common:module_mappings.bzl", "module_mappings_runtime_aspect")
 load("//internal/common:path_utils.bzl", "strip_external")
 load("//internal/common:windows_utils.bzl", "create_windows_native_launcher_script", "is_windows")
-load("//internal/linker:link_node_modules.bzl", "write_node_modules_manifest")
+load("//internal/linker:link_node_modules.bzl", "module_mappings_aspect", "write_node_modules_manifest")
 load("//internal/node:node_repositories.bzl", "BUILT_IN_NODE_PLATFORMS")
 
 def _trim_package_node_modules(package_name):
@@ -78,7 +78,7 @@ def _compute_node_modules_root(ctx):
         ] if f])
     return node_modules_root
 
-def _write_loader_script(ctx):
+def _write_loader_script(ctx, node_modules_root):
     # Generates the JavaScript snippet of module roots mappings, with each entry
     # in the form:
     #   {module_name: /^mod_name\b/, module_root: 'path/to/mod_name'}
@@ -90,8 +90,6 @@ def _write_loader_script(ctx):
                 mapping = "{module_name: /^%s\\b/, module_root: '%s'}" % (escaped, mr)
                 module_mappings.append(mapping)
 
-    node_modules_root = _compute_node_modules_root(ctx)
-
     if len(ctx.attr.entry_point.files.to_list()) != 1:
         fail("labels in entry_point must contain exactly one file")
 
@@ -165,11 +163,13 @@ def _nodejs_binary_impl(ctx):
             sources_depsets.append(d.files)
     sources = depset(transitive = sources_depsets)
 
-    _write_loader_script(ctx)
+    node_modules_root = _compute_node_modules_root(ctx)
+
+    _write_loader_script(ctx, node_modules_root)
 
     script_path = _to_manifest_path(ctx, ctx.outputs.loader)
 
-    env_vars = "export BAZEL_TARGET=%s\n" % ctx.label
+    env_vars = "export NODE_MODULES_ROOT=%s\n" % node_modules_root
     for k in ctx.attr.configuration_env_vars + ctx.attr.default_env_vars:
         if k in ctx.var.keys():
             env_vars += "export %s=\"%s\"\n" % (k, ctx.var[k])
@@ -277,7 +277,7 @@ _NODEJS_EXECUTABLE_ATTRS = {
     "data": attr.label_list(
         doc = """Runtime dependencies which may be loaded during execution.""",
         allow_files = True,
-        aspects = [node_modules_aspect, module_mappings_runtime_aspect],
+        aspects = [node_modules_aspect, module_mappings_aspect, module_mappings_runtime_aspect],
     ),
     "default_env_vars": attr.string_list(
         doc = """Default environment variables that are added to `configuration_env_vars`.
diff --git a/internal/node/npm_package_bin.bzl b/internal/node/npm_package_bin.bzl
index c2e3e10a..9aeb62e1 100644
--- a/internal/node/npm_package_bin.bzl
+++ b/internal/node/npm_package_bin.bzl
@@ -15,6 +15,7 @@ _ATTRS = {
         cfg = "host",
         mandatory = True,
     ),
+    "deps": attr.label_list(allow_files = True, aspects = [module_mappings_aspect, node_modules_aspect]),
 }
 
 # Need a custom expand_location function
@@ -46,16 +47,25 @@ def _expand_location(ctx, s):
     s = s.replace("$(@D)", "/".join([o for o in output_dir if o]))
     s = s.replace("$(RULEDIR)", "/".join([o for o in rule_dir if o]))
 
-    return ctx.expand_location(s, targets = ctx.attr.data)
+    return ctx.expand_location(s, targets = ctx.attr.data + ctx.attr.deps)
 
 def _inputs(ctx):
     # Also include files from npm fine grained deps as inputs.
     # These deps are identified by the NpmPackageInfo provider.
     inputs_depsets = []
-    for d in ctx.attr.data:
+    for d in ctx.attr.data + ctx.attr.deps:
         if NpmPackageInfo in d:
             inputs_depsets.append(d[NpmPackageInfo].sources)
-    return depset(ctx.files.data, transitive = inputs_depsets).to_list()
+    return depset(ctx.files.data + ctx.files.deps, transitive = inputs_depsets).to_list()
+
+def _transitive(ctx):
+    # Also include files from npm fine grained deps as inputs.
+    # These deps are identified by the NpmPackageInfo provider.
+    transitive_depsets = [depset(ctx.files.deps)]
+    for d in ctx.attr.deps:
+        if NpmPackageInfo in d:
+            transitive_depsets.append(d[NpmPackageInfo].sources)
+    return transitive_depsets
 
 def _impl(ctx):
     if ctx.attr.output_dir and ctx.attr.outs:
@@ -83,14 +93,14 @@ def _impl(ctx):
         outputs = outputs,
         arguments = [args],
     )
-    return [DefaultInfo(files = depset(outputs))]
+    return [DefaultInfo(files = depset(outputs, transitive = _transitive(ctx)))]
 
 _npm_package_bin = rule(
     _impl,
     attrs = _ATTRS,
 )
 
-def npm_package_bin(tool = None, package = None, package_bin = None, data = [], outs = [], args = [], output_dir = False, **kwargs):
+def npm_package_bin(tool = None, package = None, package_bin = None, data = [], deps = [], outs = [], args = [], output_dir = False, **kwargs):
     """Run an arbitrary npm package binary (e.g. a program under node_modules/.bin/*) under Bazel.
 
     It must produce outputs. If you just want to run a program with `bazel run`, use the nodejs_binary rule.
@@ -104,6 +114,7 @@ def npm_package_bin(tool = None, package = None, package_bin = None, data = [],
     Args:
         data: similar to [genrule.srcs](https://docs.bazel.build/versions/master/be/general.html#genrule.srcs)
               may also include targets that produce or reference npm packages which are needed by the tool
+        deps: dependencies that are also passed downstream transitively via DefaultInfo files
         outs: similar to [genrule.outs](https://docs.bazel.build/versions/master/be/general.html#genrule.outs)
         output_dir: set to True if you want the output to be a directory
                  Exactly one of `outs`, `output_dir` may be used.
@@ -135,6 +146,7 @@ def npm_package_bin(tool = None, package = None, package_bin = None, data = [],
         tool = "@npm//%s/bin:%s" % (package, package_bin)
     _npm_package_bin(
         data = data,
+        deps = deps,
         outs = outs,
         args = args,
         output_dir = output_dir,
